#!/usr/bin/env bash
set -euo pipefail

# Source common utilities
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=git-wt-common.sh
source "${SCRIPT_DIR}/git-wt-common.sh"

# Usage information
usage() {
  cat <<EOF
Usage: git-wt-list [OPTIONS]

List all worktrees for the current repository with merge status.

OPTIONS:
  -v, --verbose   Show verbose output (commit hashes)
  -h, --help      Show this help message

OUTPUT:
  ✓ = Branch merged into main
  • = Branch active (not merged)

EXAMPLES:
  git-wt-list           # List all worktrees
  git-wt-list -v        # List with commit information
EOF
  exit 0
}

# Parse command line arguments
VERBOSE=false

while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help)
      usage
      ;;
    -v|--verbose)
      VERBOSE=true
      shift
      ;;
    -*)
      error "Unknown option: $1"
      usage
      ;;
    *)
      error "Unexpected argument: $1"
      usage
      ;;
  esac
done

# Validate environment
validate_in_git_repo

# Get repository information — use git-common-dir to always resolve to the main repo,
# even when running from inside a worktree
REPO_ROOT="$(dirname "$(git rev-parse --path-format=absolute --git-common-dir)")"
REPO_NAME="$(basename "${REPO_ROOT}")"
MAIN_BRANCH="$(get_main_branch)"

# Get current branch
CURRENT_BRANCH="$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")"

# Get worktrees root
WORKTREES_ROOT="$(get_worktrees_root)"

# Terminal width for filling
TERM_WIDTH="$(tput cols 2>/dev/null || echo 80)"

# Print header
echo -e "${COLOR_BOLD}Main repository:${COLOR_RESET} ${REPO_ROOT}"
echo -e "${COLOR_BOLD}Current branch:${COLOR_RESET}  ${CURRENT_BRANCH}"
echo -e "${COLOR_BOLD}Worktrees root:${COLOR_RESET}  ${WORKTREES_ROOT}"
echo ""

# Parse worktree list
declare -a WORKTREES_DATA=()
CURRENT_WT=""
CURRENT_BRANCH_WT=""
CURRENT_COMMIT=""
IS_MAIN_REPO=false

while IFS= read -r line; do
  if [[ "${line}" =~ ^worktree\ (.+)$ ]]; then
    # Save previous worktree if it's not the main repo
    if [[ -n "${CURRENT_WT}" ]] && [[ "${IS_MAIN_REPO}" == false ]] && [[ "${CURRENT_WT}" != "${REPO_ROOT}" ]]; then
      WORKTREES_DATA+=("${CURRENT_WT}|${CURRENT_BRANCH_WT}|${CURRENT_COMMIT}")
    fi

    # Start new worktree
    CURRENT_WT="${BASH_REMATCH[1]}"
    CURRENT_BRANCH_WT=""
    CURRENT_COMMIT=""
    IS_MAIN_REPO=false

  elif [[ "${line}" =~ ^HEAD\ ([a-f0-9]+)$ ]]; then
    CURRENT_COMMIT="${BASH_REMATCH[1]}"

  elif [[ "${line}" =~ ^branch\ refs/heads/(.+)$ ]]; then
    CURRENT_BRANCH_WT="${BASH_REMATCH[1]}"

  elif [[ "${line}" =~ ^bare$ ]]; then
    IS_MAIN_REPO=true

  elif [[ "${line}" == "" ]]; then
    # Empty line, might be end of entry
    continue
  fi
done < <(git worktree list --porcelain)

# Save last worktree if it's not the main repo
if [[ -n "${CURRENT_WT}" ]] && [[ "${IS_MAIN_REPO}" == false ]] && [[ "${CURRENT_WT}" != "${REPO_ROOT}" ]]; then
  WORKTREES_DATA+=("${CURRENT_WT}|${CURRENT_BRANCH_WT}|${CURRENT_COMMIT}")
fi

# Check if there are any worktrees
if [[ ${#WORKTREES_DATA[@]} -eq 0 ]]; then
  echo "No worktrees found."
  echo ""
  echo "Create one with:"
  echo "  git-wt-add <branch-name>"
  exit 0
fi

# Print worktrees
echo -e "${COLOR_BOLD}Worktrees:${COLOR_RESET}"

for entry in "${WORKTREES_DATA[@]}"; do
  IFS='|' read -r wt_path wt_branch wt_commit <<< "${entry}"

  wt_name="$(basename "${wt_path}")"

  # Determine status
  if is_branch_merged "${wt_branch}"; then
    SYMBOL="${COLOR_GREEN}✓${COLOR_RESET}"
    STATUS="${COLOR_GREEN}[MERGED]${COLOR_RESET}"
  elif [[ -z "$(git branch -r --list "origin/${wt_branch}")" ]]; then
    SYMBOL="${COLOR_RED}!${COLOR_RESET}"
    STATUS="${COLOR_RED}[UNTRACKED]${COLOR_RESET}"
  else
    SYMBOL="${COLOR_BLUE}•${COLOR_RESET}"
    STATUS="${COLOR_BLUE}[ACTIVE]${COLOR_RESET}"
  fi

  # Check for uncommitted changes
  if [[ -n "$(git -C "${wt_path}" status --porcelain 2>/dev/null)" ]]; then
    STATUS+=" ${COLOR_YELLOW}[DIRTY]${COLOR_RESET}"
  fi

  # Build right side: folder-name (with optional commit hash in verbose mode)
  if [[ "${VERBOSE}" == true ]]; then
    right_side="${wt_name}  ${wt_commit:0:8}"
  else
    right_side="${wt_name}"
  fi

  # Calculate padding — show folder name only when terminal is wide enough
  status_plain="$(echo -e "${STATUS}" | sed 's/\x1b\[[0-9;]*m//g')"
  left_len=$(( 4 + ${#wt_branch} ))

  if (( TERM_WIDTH > 100 )); then
    # Wide: symbol branch ... folder  status
    right_len=$(( ${#right_side} + 2 + ${#status_plain} ))
    pad_len=$(( TERM_WIDTH - left_len - right_len ))
    (( pad_len < 2 )) && pad_len=2
    padding="$(printf '%*s' "${pad_len}" '')"
    printf "  %b %s%s${COLOR_DIM}%s${COLOR_RESET}  %b\n" \
      "${SYMBOL}" "${wt_branch}" "${padding}" "${right_side}" "${STATUS}"
  else
    # Narrow: symbol branch ... status
    right_len=$(( ${#status_plain} ))
    pad_len=$(( TERM_WIDTH - left_len - right_len ))
    (( pad_len < 2 )) && pad_len=2
    padding="$(printf '%*s' "${pad_len}" '')"
    printf "  %b %s%s%b\n" \
      "${SYMBOL}" "${wt_branch}" "${padding}" "${STATUS}"
  fi
done

echo ""
echo "Legend:"
echo -e "  ${COLOR_GREEN}✓${COLOR_RESET} = Merged into ${MAIN_BRANCH}"
echo -e "  ${COLOR_BLUE}•${COLOR_RESET} = Active (not merged)"
echo -e "  ${COLOR_RED}!${COLOR_RESET} = Untracked (no remote branch)"
echo -e "  ${COLOR_YELLOW}~${COLOR_RESET} = Dirty (uncommitted changes)"

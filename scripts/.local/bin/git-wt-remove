#!/usr/bin/env bash
set -euo pipefail

# Source common utilities
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=git-wt-common.sh
source "${SCRIPT_DIR}/git-wt-common.sh"

# Usage information
usage() {
  cat <<EOF
Usage: git-wt-remove [OPTIONS] [branch-name|path]

Remove a git worktree interactively or by specifying branch name or path.

OPTIONS:
  -f, --force     Force removal without confirmation
  -d, --delete    Also delete the branch if it's merged
  -h, --help      Show this help message

EXAMPLES:
  git-wt-remove                    # Interactive selection with fzf
  git-wt-remove feat/old-feature   # Remove by branch name
  git-wt-remove ~/path/to/wt       # Remove by path
  git-wt-remove -f -d feat/done    # Force remove and delete merged branch
EOF
  exit 0
}

# Parse command line arguments
FORCE=false
DELETE_BRANCH=false
TARGET=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help)
      usage
      ;;
    -f|--force)
      FORCE=true
      shift
      ;;
    -d|--delete)
      DELETE_BRANCH=true
      shift
      ;;
    -*)
      error "Unknown option: $1"
      usage
      ;;
    *)
      if [[ -z "${TARGET}" ]]; then
        TARGET="$1"
      else
        error "Too many arguments"
        usage
      fi
      shift
      ;;
  esac
done

# Validate environment
validate_in_git_repo

# Get repository information — use git-common-dir to always resolve to the main repo,
# even when running from inside a worktree
REPO_ROOT="$(dirname "$(git rev-parse --path-format=absolute --git-common-dir)")"
MAIN_BRANCH="$(get_main_branch)"

# Function to get worktree info for interactive selection
get_worktree_list() {
  declare -a WORKTREES_DATA=()
  CURRENT_WT=""
  CURRENT_BRANCH_WT=""
  
  while IFS= read -r line; do
    if [[ "${line}" =~ ^worktree\ (.+)$ ]]; then
      # Save previous worktree if it's not the main repo
      if [[ -n "${CURRENT_WT}" ]] && [[ "${CURRENT_WT}" != "${REPO_ROOT}" ]]; then
        WORKTREES_DATA+=("${CURRENT_WT}|${CURRENT_BRANCH_WT}")
      fi
      
      CURRENT_WT="${BASH_REMATCH[1]}"
      CURRENT_BRANCH_WT=""
      
    elif [[ "${line}" =~ ^branch\ refs/heads/(.+)$ ]]; then
      CURRENT_BRANCH_WT="${BASH_REMATCH[1]}"
    fi
  done < <(git worktree list --porcelain)
  
  # Save last worktree if it's not the main repo
  if [[ -n "${CURRENT_WT}" ]] && [[ "${CURRENT_WT}" != "${REPO_ROOT}" ]]; then
    WORKTREES_DATA+=("${CURRENT_WT}|${CURRENT_BRANCH_WT}")
  fi
  
  # Return the array
  printf '%s\n' "${WORKTREES_DATA[@]}"
}

# Function to find worktree by branch name or path
find_worktree() {
  local search="$1"
  local found_path=""
  local found_branch=""
  
  while IFS='|' read -r wt_path wt_branch; do
    # Match by branch name or path
    if [[ "${wt_branch}" == "${search}" ]] || [[ "${wt_path}" == "${search}" ]] || [[ "$(basename "${wt_path}")" == "${search}" ]]; then
      found_path="${wt_path}"
      found_branch="${wt_branch}"
      break
    fi
  done < <(get_worktree_list)
  
  if [[ -n "${found_path}" ]]; then
    echo "${found_path}|${found_branch}"
    return 0
  else
    return 1
  fi
}

# Guard against removing the main branch
if [[ -n "${TARGET}" ]] && [[ "${TARGET}" == "${MAIN_BRANCH}" ]]; then
  error "Cannot remove the main branch (${MAIN_BRANCH})"
  exit 1
fi

# If no target specified, use interactive mode with fzf
if [[ -z "${TARGET}" ]]; then
  if ! command -v fzf >/dev/null 2>&1; then
    error "fzf is required for interactive mode"
    echo "Install fzf or specify a branch name/path directly" >&2
    exit 1
  fi
  
  # Get worktree list
  WORKTREE_LIST="$(get_worktree_list)"
  
  if [[ -z "${WORKTREE_LIST}" ]]; then
    echo "No worktrees found."
    exit 0
  fi
  
  # Show tree preview only on wide terminals (>140 cols)
  FULL_WIDTH="$(tput cols 2>/dev/null || echo 80)"
  SHOW_PREVIEW=false
  if (( FULL_WIDTH > 140 )); then
    SHOW_PREVIEW=true
  fi

  # Format for fzf display (tab-delimited: display \t branch \t path)
  FZF_INPUT=""
  while IFS='|' read -r wt_path wt_branch; do
    wt_name="$(basename "${wt_path}")"

    # Determine primary status
    if is_branch_merged "${wt_branch}"; then
      symbol="✓"
      status="${COLOR_GREEN}[MERGED]${COLOR_RESET}"
    elif [[ -z "$(git branch -r --list "origin/${wt_branch}")" ]]; then
      symbol="!"
      status="${COLOR_RED}[UNTRACKED]${COLOR_RESET}"
    else
      symbol="•"
      status="${COLOR_BLUE}[ACTIVE]${COLOR_RESET}"
    fi

    # Check for uncommitted changes
    if [[ -n "$(git -C "${wt_path}" status --porcelain 2>/dev/null)" ]]; then
      status+=" ${COLOR_YELLOW}[DIRTY]${COLOR_RESET}"
    fi

    # Use fixed-width columns — fzf pane width is unpredictable so avoid right-alignment
    if [[ "${SHOW_PREVIEW}" == true ]]; then
      display="$(printf "  %s %-40s ${COLOR_DIM}%-45s${COLOR_RESET}  %b" \
        "${symbol}" "${wt_branch}" "${wt_name}" "${status}")"
    else
      display="$(printf "  %s %-40s %b" \
        "${symbol}" "${wt_branch}" "${status}")"
    fi

    FZF_INPUT+="${display}"$'\t'"${wt_branch}"$'\t'"${wt_path}"$'\n'
  done <<< "${WORKTREE_LIST}"

  # Build fzf command with optional preview
  FZF_OPTS=(--ansi --header="Select worktree to remove:" --delimiter=$'\t' --with-nth=1)
  if [[ "${SHOW_PREVIEW}" == true ]]; then
    if command -v tree >/dev/null 2>&1; then
      FZF_OPTS+=(--preview='tree -C -L 2 {3}')
    else
      FZF_OPTS+=(--preview='ls -la --color=always {3}')
    fi
    FZF_OPTS+=(--preview-window=right:50%)
  fi

  # Use fzf to select
  SELECTED=$(echo -n "${FZF_INPUT}" | fzf "${FZF_OPTS[@]}")

  if [[ -z "${SELECTED}" ]]; then
    echo "No worktree selected."
    exit 0
  fi

  # Extract branch and path from selection (tab-delimited, tab is cut's default)
  BRANCH_NAME="$(echo "${SELECTED}" | cut -f2)"
  WORKTREE_PATH="$(echo "${SELECTED}" | cut -f3)"
else
  # Find worktree by target
  if ! FOUND_INFO="$(find_worktree "${TARGET}")"; then
    error "Worktree not found: ${TARGET}"
    echo ""
    echo "Available worktrees:"
    while IFS='|' read -r wt_path wt_branch; do
      echo "  - ${wt_branch} ($(basename "${wt_path}"))"
    done < <(get_worktree_list)
    exit 1
  fi
  
  WORKTREE_PATH="${FOUND_INFO%%|*}"
  BRANCH_NAME="${FOUND_INFO##*|}"
fi

# Confirm removal unless force flag is set
if [[ "${FORCE}" != true ]]; then
  echo "Removing worktree:"
  echo "  Name: $(basename "${WORKTREE_PATH}")"
  echo "  Branch: ${BRANCH_NAME}"
  echo "  Path: ${WORKTREE_PATH}"
  echo ""
  
  # Check if branch is merged
  if is_branch_merged "${BRANCH_NAME}"; then
    echo -e "  Status: ${COLOR_GREEN}[MERGED into ${MAIN_BRANCH}]${COLOR_RESET}"
  else
    echo -e "  Status: ${COLOR_YELLOW}[NOT MERGED - may contain uncommitted work]${COLOR_RESET}"
  fi
  echo ""
  
  read -rp "Are you sure? [y/N]: " confirm
  if [[ ! "${confirm}" =~ ^[Yy]$ ]]; then
    echo "Aborted."
    exit 0
  fi
fi

# Remove the worktree
echo "Removing worktree..."
if git worktree remove "${WORKTREE_PATH}" 2>/dev/null; then
  success "✓ Worktree removed successfully"
else
  # Try force remove if it has modifications
  warning "Worktree has modifications, forcing removal..."
  if git worktree remove --force "${WORKTREE_PATH}"; then
    success "✓ Worktree force-removed successfully"
  else
    error "Failed to remove worktree"
    exit 1
  fi
fi

# Offer to delete the branch if it's merged
if [[ "${DELETE_BRANCH}" == true ]] && is_branch_merged "${BRANCH_NAME}"; then
  echo ""
  echo "Branch '${BRANCH_NAME}' is merged into ${MAIN_BRANCH}."
  
  if [[ "${FORCE}" != true ]]; then
    read -rp "Delete the branch? [y/N]: " delete_confirm
    if [[ ! "${delete_confirm}" =~ ^[Yy]$ ]]; then
      echo "Branch kept."
      exit 0
    fi
  fi
  
  echo "Deleting branch..."
  if git branch -d "${BRANCH_NAME}" 2>/dev/null; then
    success "✓ Branch deleted successfully"
  else
    warning "Failed to delete branch (it may still be in use)"
  fi
elif is_branch_merged "${BRANCH_NAME}" && [[ "${DELETE_BRANCH}" != true ]]; then
  echo ""
  info "Tip: Branch '${BRANCH_NAME}' is merged. Delete it with:"
  echo "  git branch -d ${BRANCH_NAME}"
  echo "  or use: git-wt-remove -d ${BRANCH_NAME}"
fi
